TC - O(2^n × k)
(The program explores many paths — roughly doubling possibilities each time —
so time grows exponentially with input size)

SC - O(K * X) 
(length of array * all combinations)




class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        
        List<List<Integer>> ans = new ArrayList<>();
        findCombinations(0,candidates,target,ans,new ArrayList<>());
        return ans;
    }

        private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){
            
            //base case
            if(ind == arr.length)
            {
                if(target == 0)
                {
                    ans.add(new ArrayList<>(ds));
                    
                }
                return; //even if target not completed but it reached end return immediately
            }


            //if included
            if(arr[ind]<= target)
            {
                ds.add(arr[ind]);      //add that element into data structure

                findCombinations(ind,arr,target-arr[ind],ans,ds);

                ds.remove(ds.size()-1);  //free up that data structure while backtracking
            }

            //if excluded
            findCombinations(ind+1,arr,target,ans,ds);    //as we are not intrested we will move to next index

        }
    
}
